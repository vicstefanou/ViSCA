#' Import \emph{SuperSegger} data
#'
#' Imports a \code{.csv} file generated by \emph{SuperSegger} and converts them into
#' a cell list and colony list containing all the cell instants and colony instants of the movie, respectively.
#'
#' \emph{SuperSegger} treats the whole frame as a single colony.
#' \cr\cr
#' \emph{SuperSegger} users importing the data with this function are \bold{excluded} from using
#' \code{\link{split_cell}}, \code{\link{get_cand_merge_cells}} and \code{\link{merge_cells}}.
#'
#' @param file A character string naming the \code{.csv} file generated by \emph{Oufti}
#' (including the suffix \code{".csv"}) from which the data is to be imported.
#' If it does not contain an absolute path, the file name is relative to the current working directory, \code{getwd()}.
#' \cr\cr
#' NOTE: The components should be separated by \code{"/"} on Windows.
#'
#' @param pixelR The pixel ratio in units of length, a non-zero positive numeric value.
#'
#' @return A named list with the following components:
#' \item{col_list}{A list containing all the colony instants of the movie.
#' Each element of the list is a named list with the following components:
#' \itemize{
#' \item \code{colName} is the name of the colony instant, a character string in the format \code{"f<frame>_c1"},
#' where \code{"<frame>"} is the ID of the frame of the colony instant.
#' \item \code{prev_colName} is a vector of character strings containing the \code{colName}
#' of the corresponding colony instant(s) in the previous frame.
#' For colony instants of the first frame, this is equal to \code{"f0_c0"}.
#' \item \code{next_colName} is a character string containing the \code{colName}
#' of the corresponding colony instant in the next frame.
#' For colony instants of the last frame, this is equal to \code{"f00_c0"}.
#' \item \code{colImage} is the mask of the box surrounding the colony instant, a matrix of \code{0} and \code{1}.
#' \code{1}s denote the pixels of cells and \code{0}s the background pixels.
#' \item \code{ULcorner} is an 1x2 matrix of non-zero integer values
#' denoting the upper-left pixel of the box surrounding the colony instant in global (frame) coordinates.
#' The first integer represents the row and the second the column of the pixel.
#' }
#' }
#'
#' \item{cell_list}{A list containing all the cell instants of the movie.
#' Each element of the list is a named list with the following components:
#' \itemize{
#' \item \code{cellName} is the name of the cell, a character string in the format \code{"c<cellId>_f<frame>"}.
#' \item \code{frame} is the ID of the frame of the cell, a non-zero positive integer number.
#' \item \code{colony} is the ID of the colony of the cell in the \code{frame}, a non-zero positive integer number.
#' \item \code{daughterIds} is a vector of character strings containing the \code{cellName}
#' of the linked cell(s) in the next frame,
#' or \code{NULL} in case no such cells exist.
#' \item \code{colId} is a \emph{pointer} to the corresponding colony instant of the cell in the \code{col_list},
#' a non-zero positive integer value.
#' \cr\cr
#' Colonies that entered the field of view at a time point and did not exist from the beginning of the movie (i.e. from the first frame)
#' should not have tracked cells, until they merge (if this is the case) with another existing colony.
#' This means that no element should \emph{point} to such colony instants.
#' \item \code{pixelList} is a Nx2 matrix of non-zero integer values
#' denoting the pixels of the cell in colony coordinates
#' (i.e. relative to the \code{colImage} of the \code{colId}^th element in the \code{col_list}).
#' Each one of the N rows indicates a pixel of the cell.
#' The first column represents the row and the second the column of the pixel.
#' \item \code{centroid} is an 1x2 matrix of non-zero numeric values
#' denoting the centroid (geometric center) of the cell in colony coordinates
#' (i.e. relative to the \code{colImage} of the \code{colId}^th element in the \code{col_list}).
#' It is the \emph{mean} of the \code{pixelList} by column.
#' \item \code{length} is the length of the cell in units of length, a non-zero positive numeric value.
#' \item \code{width} is the width of the cell in units of length, a non-zero positive numeric value.
#' \item \code{LW} is the length-to-width ratio, a non-zero positive numeric value.
#' \item \code{area} is the area of the cell in squared units of length, a non-zero positive numeric value.
#' \item \code{perimeter} is the perimeter of the cell in units of length, a non-zero positive numeric value.
#' \item \code{eccentricity} is a numeric value in the range \code{[0, 1]}
#' defining the eccentricity of the cell.
#' \item \code{orientation} is a numeric value in the range \code{[0, 360)}
#' defining the orientation of the cell in \emph{degrees}.
#' \item \code{solidity} is a numeric value in the range \code{[0, 1]}
#' defining the solidity of the cell.
#' \item \code{fluorescenceInt<i>} is a Nx1 matrix of positive numeric values indicating the
#' fluoresence intensity of channel \code{<i>} for each one of the pixels in \code{pixelList}
#' (1-1 correspondence).
#' \item \code{fluorescenceInt<i>.mean} is the \emph{mean} of \code{fluorescenceInt<i>}, a positive numeric value.
#' \item \code{fluorescenceInt<i>.std} is the \emph{standard deviation} of \code{fluorescenceInt<i>}, a positive numeric value.
#' \item \code{fluorescenceInt<i>.coverage} is the percentage of the cell area covered by fluoresence,
#' a numeric value in the range \code{[0, 1]}.
#' }
#' }
#'
#' \item{Nframes}{Number of frames in the movie, a non-zero positive integer value.
#' IDs of frames are in the range \code{[1, Nframes]}.}
#' \item{Ncols}{Number of colonies in the movie, equal to \code{1}.
#' IDs of colonies are in the range \code{[1, Ncols]}.}
#' \item{frameH}{Frame image height in \emph{pixels}, a non-zero positive integer value.}
#' \item{frameW}{Frame image width in \emph{pixels}, a non-zero positive integer value.}
#'
#' @references \url{http://mtshasta.phys.washington.edu/website/SuperSegger.php}
#' @export


# [somebasename]t[number]xy[number]c[number].tif
# [somebasename]t[number]          c[number].tif
#
# [somebasename]t[number]xy[number]_err.mat
#
# [somebasename]         xy[number]
#                 Ndigits, first, last

# #"mask_cell" : 0/1 for background/cells -> colIm
# regs
#   "daughterID" : cell array with Cell ID of daughter cells
#   "ID" : ID of each cell
# CellA
#   "cellLength" : (1) max length and (2) mean width of the cell (in pixels)
# #  "mask" : logical (1 and 0) image of the cell mask, unoriented -> from matrix to pixelList  + r_offset -> on frame/colony
#   --> centroid -> mean pixelList (+ r_offset) se kathe diastasi
# #  "r.offset" : global coordinates of the top left edge of the cellâ€™s bounding box
#   "edgeFlag" : true (1) if the cell is at the edge of the image
#   coord
#     "orientation" -> "-" -> 360 - "-"
#     "A" : Area of cell mask
#   pole
# fl1, fl2 klp


import_ss <- function(path = "/home/vic/Desktop/sal15_9_ss",
                      somebasename = "sal15_9", # "2014_05_30_controlagain"
                      xy_number = "", # "xy1" or ""
                      Ndigits = 3, Nframes,
                      pixelR) {

  for (i_frame in 1:Nframes) {

    file <- paste(path, "/", somebasename, "t", formatC(i_frame, width = Ndigits, format = "d", flag = "0"), xy_number, "_err.mat", sep = "")
    mat_file <- R.matlab::readMat(file)

    if (i_frame != 1) {
      prev_colName <- paste("f", i_frame - 1, "_c1", sep = "")
    } else {
      prev_colName <- "f0_c0"
    }

    if (i_frame != Nframes) {
      next_colName <- paste("f", i_frame + 1, "_c1", sep = "")
    } else {
      next_colName <- "f00_c0"
    }

    colImage <- t(mat_file$mask.cell)

    col_list[[curr_colony]] <- list(colName = paste("f", i_frame, "_c1", sep = ""),
                                       colImage = colImage,
                                       prev_colName = prev_colName,
                                       next_colName = next_colName,
                                       ULcorner = c(1, 1))

    if (i_frame == 1){
      frameH <- as.vector(data[, i_frame]$x)
      frameW <- as.vector(data[, i_frame]$y)
    }

    cell_pixels <- t(mat_file$CellA[[i_cell]][[1]][,,1]$mask)
    pixelList <- which(cell_pixels == 1, arr.in=TRUE) # row, col
    ULcorner <- mat_file$CellA[[i_cell]][[1]][,,1]$r.offset
    pixelList <- cbind(pixelList[,1] + ULcorner[1], pixelList[,2] + ULcorner[2])


    for (i_cell in 1:ncol(data[, i_frame]$colonyProps[, , i_colony]$cellProps[, , 1])) {
      curr_cell <- curr_cell + 1
      cell_list[[curr_cell]] <- data[, i_frame]$colonyProps[, , i_colony]$cellProps[, , 1][, i_cell]
      cell_list[[curr_cell]] <- updateCellInList(x = cell_list[[curr_cell]],
                                                 frame = i_frame,
                                                 colony = i_colony,
                                                 colId = curr_colony,
                                                 col_list = col_list,
                                                 pixelRatio = pixelR)

      x$frame <- i_frame
      x$colony <- colony

      x$colId <- colId

      x$cellName <- paste(x$cellName, "_f", x$frame, sep = "")

      if (!is.null(x$daughterIds)) {
        if (length(x$daughterIds) == 0) {
          x$daughterIds <- NULL
        } else {
          x$daughterIds <- paste(x$daughterIds, "_f", x$frame + 1, sep = "")
        }
      }

      x$length <- as.numeric(x$length) * pixelR
      x$width <- as.numeric(x$width) * pixelR
      x$LW <-  x$length / x$width
      x$area <- dim(x$pixelList)[1] * pixelR * pixelR

      # values from matrix format
      for (attr in names(x)) {
        if (is.matrix(x[[attr]])) {
          if (dim(x[[attr]])[1] == 1 & dim(x[[attr]])[2] == 1) {
            x[[attr]] <- as.vector(x[[attr]])
          }
        }
      }

    }

  }

  cat("Checking colony list...\n")
  checkColList(col_list = col_list, frameH = frameH, frameW = frameW)
  cat("Checking cell list...\n")
  cell_list <- checkCellList(cell_list = cell_list, col_list = col_list)

  return(list(col_list = col_list, cell_list = cell_list,
              Ncols = 1,
              frameH = frameH, frameW = frameW))

}
